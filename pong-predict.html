<!-- ✨ UPDATED PONG PREDICT ✨ -->
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Pong Predict</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      background: black;
      color: white;
      font-family: 'Courier New', monospace;
      overflow: hidden;
      height: 100%;
    }

    #intro {
      position: absolute;
      top: 0; left: 0;
      width: 100%; height: 100%;
      background: black;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      text-align: center;
      padding: 40px;
      font-size: 16px;
      z-index: 10;
    }

    #game {
      display: flex;
      width: 100vw;
      height: 100vh;
    }

    canvas {
      flex: 1;
      height: 100%;
      background: black;
    }

    .score {
      position: absolute;
      top: 20px;
      font-size: 32px;
      font-weight: bold;
      color: white;
      z-index: 2;
    }

    #playerScore {
      left: 30px;
    }

    #aiScore {
      right: 30px;
    }

    .vhs {
      filter: contrast(1.1) brightness(1.15);
      animation: flicker 6s infinite;
    }

    @keyframes flicker {
      0%, 95%, 100% { opacity: 1; }
      97% { opacity: 0; }
    }
  </style>
</head>
<body>
  <div id="intro">
    <p><strong>Open Testing:</strong><br>Pong Predict is a small-scale experiment which will simulate ~120 games of pong in order to predict the outcome 5 seconds into the future.</p>
    <p>The display on the right will show the predicted score.</p>
    <p>Press <strong>Esc</strong> to end the simulation.<br>Press <strong>Return</strong> to enter the simulation.</p>
    <p><em>Note:</em> I thought this was self-explanatory but I got an email from David, who couldn't work out the up and down arrow keys move your paddle. Shame on you, David.<br>Also, sorry to our mobile workers — the simulation is in a primitive state and is almost unplayable on mobile.</p>
  </div>

  <div id="playerScore" class="score">0</div>
  <div id="aiScore" class="score">0</div>

  <div id="game" style="display:none">
    <canvas id="gameCanvas"></canvas>
    <canvas id="predictionCanvas" class="vhs"></canvas>
  </div>

  <script>
    const intro = document.getElementById("intro");
    const gameContainer = document.getElementById("game");
    const playerScoreElem = document.getElementById("playerScore");
    const aiScoreElem = document.getElementById("aiScore");

    let started = false;
    document.addEventListener("keydown", (e) => {
      if (e.key === "Enter" && !started) {
        intro.style.display = "none";
        gameContainer.style.display = "flex";
        started = true;
        startGame();
      }
    });

    function startGame() {
      const canvas = document.getElementById("gameCanvas");
      const ctx = canvas.getContext("2d");
      const predCanvas = document.getElementById("predictionCanvas");
      const predCtx = predCanvas.getContext("2d");

      canvas.width = predCanvas.width = window.innerWidth / 2;
      canvas.height = predCanvas.height = window.innerHeight;

      const paddleWidth = 10, paddleHeight = 100, ballSize = 10;
      let playerY = canvas.height / 2 - paddleHeight / 2;
      let aiY = playerY;
      let ballX = canvas.width / 2, ballY = canvas.height / 2;
      let ballVX = 3, ballVY = 2;
      let playerScore = 0, aiScore = 0;

      const keys = {};
      document.addEventListener("keydown", (e) => keys[e.key] = true);
      document.addEventListener("keyup", (e) => keys[e.key] = false);

      function drawScene(context, py, ay, bx, by, vx, vy) {
        context.clearRect(0, 0, canvas.width, canvas.height);
        context.fillStyle = "white";

        // Paddles
        context.fillRect(0, py, paddleWidth, paddleHeight);
        context.fillRect(canvas.width - paddleWidth, ay, paddleWidth, paddleHeight);

        // Ball
        context.fillRect(bx, by, ballSize, ballSize);

        // Predictive bounding boxes
        context.strokeStyle = "white";
        for (let i = 1; i <= 3; i++) {
          const predX = bx + vx * i * 20;
          const predY = by + vy * i * 20;
          context.strokeRect(predX, predY, ballSize, ballSize);
        }

        // Outer bounding box
        context.strokeStyle = "rgba(255,255,255,0.3)";
        context.lineWidth = 2;
        context.strokeRect(0, 0, canvas.width, canvas.height);
      }

      function resetBall() {
        ballX = canvas.width / 2;
        ballY = canvas.height / 2;
        ballVX = Math.random() < 0.5 ? 3 : -3;
        ballVY = (Math.random() - 0.5) * 4;
      }

      function updateGame() {
        if (keys["ArrowUp"]) playerY -= 4;
        if (keys["ArrowDown"]) playerY += 4;
        playerY = Math.max(0, Math.min(canvas.height - paddleHeight, playerY));

        const aiCenter = aiY + paddleHeight / 2;
        if (aiCenter < ballY - 10) aiY += 2;
        else if (aiCenter > ballY + 10) aiY -= 2;
        aiY = Math.max(0, Math.min(canvas.height - paddleHeight, aiY));

        ballX += ballVX;
        ballY += ballVY;

        if (ballY <= 0 || ballY >= canvas.height - ballSize) ballVY = -ballVY;

        // Paddle collision
        if (ballX <= paddleWidth && ballY + ballSize >= playerY && ballY <= playerY + paddleHeight) {
          ballVX = Math.abs(ballVX);
          ballVY += (Math.random() - 0.5) * 2;
        }
        if (ballX >= canvas.width - paddleWidth - ballSize && ballY + ballSize >= aiY && ballY <= aiY + paddleHeight) {
          ballVX = -Math.abs(ballVX);
          ballVY += (Math.random() - 0.5) * 2;
        }

        if (ballX < 0) {
          aiScore++;
          resetBall();
        }
        if (ballX > canvas.width) {
          playerScore++;
          resetBall();
        }

        playerScoreElem.textContent = playerScore;
        aiScoreElem.textContent = aiScore;

        drawScene(ctx, playerY, aiY, ballX, ballY, ballVX, ballVY);
      }

      function predictFuture() {
        let px = playerY, ax = aiY, bx = ballX, by = ballY, vx = ballVX, vy = ballVY;

        for (let i = 0; i < 300; i++) {
          if (bx <= paddleWidth && by + ballSize >= px && by <= px + paddleHeight) {
            vx = Math.abs(vx);
            vy += (Math.random() - 0.5);
          }
          if (bx >= canvas.width - paddleWidth - ballSize && by + ballSize >= ax && by <= ax + paddleHeight) {
            vx = -Math.abs(vx);
            vy += (Math.random() - 0.5);
          }
          if (by < 0 || by > canvas.height - ballSize) vy = -vy;

          bx += vx;
          by += vy;

          const aiMid = ax + paddleHeight / 2;
          if (aiMid < by - 10) ax += 2;
          else if (aiMid > by + 10) ax -= 2;
          ax = Math.max(0, Math.min(canvas.height - paddleHeight, ax));
        }

        drawScene(predCtx, px, ax, bx, by, vx, vy);
      }

      function gameLoop() {
        updateGame();
        predictFuture();
        requestAnimationFrame(gameLoop);
      }

      gameLoop();
    }
  </script>
</body>
</html>
