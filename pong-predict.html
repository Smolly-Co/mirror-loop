<!-- Updated Pong Predict HTML -->
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Pong Predict</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      background: black;
      color: white;
      font-family: 'Courier New', monospace;
      overflow: hidden;
      height: 100%;
    }

    #intro {
      position: absolute;
      top: 0; left: 0;
      width: 100%; height: 100%;
      background-color: black;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      font-size: 14px;
      padding: 20px;
      box-sizing: border-box;
      text-align: center;
      z-index: 2;
    }

    #game {
      display: flex;
      width: 100vw;
      height: 100vh;
    }

    canvas {
      flex: 1;
      height: 100%;
      background-color: black;
    }

    .score {
      position: absolute;
      top: 10px;
      font-size: 28px;
      font-weight: bold;
      color: white;
      z-index: 1;
    }

    #playerScore {
      left: 40px;
    }

    #aiScore {
      right: 40px;
    }

    .vhs {
      filter: contrast(1.1) brightness(1.2);
      animation: flicker 5s infinite;
    }

    @keyframes flicker {
      0%, 90%, 100% { opacity: 1; }
      95% { opacity: 0; }
    }
  </style>
</head>
<body>
  <div id="intro">
    <p><strong>Open Testing:</strong> Pong Predict simulates ~120 games of pong to predict the outcome 5 seconds into the future.</p>
    <p>The right display shows predicted score & positions.</p>
    <p>Press <strong>Return</strong> to enter. Press <strong>Esc</strong> to exit.</p>
    <p><em>Note:</em> Up/Down arrows to move your paddle. Yes, David. It really is that simple.</p>
  </div>

  <div id="playerScore" class="score">0</div>
  <div id="aiScore" class="score">0</div>

  <div id="game" style="display: none">
    <canvas id="gameCanvas"></canvas>
    <canvas id="predictionCanvas" class="vhs"></canvas>
  </div>

  <script>
    const intro = document.getElementById("intro");
    const gameContainer = document.getElementById("game");
    const playerScoreElem = document.getElementById("playerScore");
    const aiScoreElem = document.getElementById("aiScore");

    let started = false;
    document.addEventListener("keydown", (e) => {
      if (e.key === "Enter" && !started) {
        intro.style.display = "none";
        gameContainer.style.display = "flex";
        started = true;
        startGame();
      }
    });

    function startGame() {
      const canvas = document.getElementById("gameCanvas");
      const ctx = canvas.getContext("2d");
      const predCanvas = document.getElementById("predictionCanvas");
      const predCtx = predCanvas.getContext("2d");

      canvas.width = predCanvas.width = window.innerWidth / 2;
      canvas.height = predCanvas.height = window.innerHeight;

      const paddleHeight = 100, paddleWidth = 10, ballSize = 10;
      let playerY = canvas.height / 2 - paddleHeight / 2;
      let aiY = playerY;
      let ballX = canvas.width / 2, ballY = canvas.height / 2;
      let ballVX = 3, ballVY = 2;
      let playerScore = 0, aiScore = 0;

      const keys = {};
      document.addEventListener("keydown", e => keys[e.key] = true);
      document.addEventListener("keyup", e => keys[e.key] = false);

      function drawScene(ctx, px, py, ax, ay, bx, by, vx, vy) {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = "white";

        // Draw paddles
        ctx.fillRect(0, py, paddleWidth, paddleHeight);
        ctx.fillRect(canvas.width - paddleWidth, ay, paddleWidth, paddleHeight);

        // Bounding boxes for paddles
        ctx.strokeStyle = "#444";
        ctx.strokeRect(0, py, paddleWidth, paddleHeight);
        ctx.strokeRect(canvas.width - paddleWidth, ay, paddleWidth, paddleHeight);

        // Ball
        ctx.fillRect(bx, by, ballSize, ballSize);

        // Prediction trail
        ctx.strokeStyle = "white";
        for (let i = 1; i <= 3; i++) {
          ctx.strokeRect(bx + vx * i * 20, by + vy * i * 20, ballSize, ballSize);
        }
      }

      function updateGame() {
        if (keys["ArrowUp"]) playerY -= 4;
        if (keys["ArrowDown"]) playerY += 4;
        playerY = Math.max(0, Math.min(canvas.height - paddleHeight, playerY));

        const aiCenter = aiY + paddleHeight / 2;
        if (aiCenter < ballY - 10) aiY += 2;
        else if (aiCenter > ballY + 10) aiY -= 2;
        aiY = Math.max(0, Math.min(canvas.height - paddleHeight, aiY));

        ballX += ballVX;
        ballY += ballVY;

        if (ballY <= 0 || ballY >= canvas.height - ballSize) ballVY *= -1;

        if (ballX <= paddleWidth &&
            ballY + ballSize > playerY &&
            ballY < playerY + paddleHeight) {
          ballVX = Math.abs(ballVX);
          ballVY += (Math.random() - 0.5) * 2;
        }

        if (ballX >= canvas.width - paddleWidth - ballSize &&
            ballY + ballSize > aiY &&
            ballY < aiY + paddleHeight) {
          ballVX = -Math.abs(ballVX);
          ballVY += (Math.random() - 0.5) * 2;
        }

        if (ballX < 0) {
          aiScore++;
          resetBall();
        } else if (ballX > canvas.width) {
          playerScore++;
          resetBall();
        }

        playerScoreElem.textContent = playerScore;
        aiScoreElem.textContent = aiScore;

        drawScene(ctx, 0, playerY, canvas.width - paddleWidth, aiY, ballX, ballY, ballVX, ballVY);
      }

      function predictFuture() {
        let px = playerY, ax = aiY, bx = ballX, by = ballY;
        let vx = ballVX, vy = ballVY;

        for (let i = 0; i < 300; i++) {
          if (bx <= paddleWidth && by + ballSize > px && by < px + paddleHeight) {
            vx = Math.abs(vx);
            vy += (Math.random() - 0.5);
          }
          if (bx >= canvas.width - paddleWidth - ballSize && by + ballSize > ax && by < ax + paddleHeight) {
            vx = -Math.abs(vx);
            vy += (Math.random() - 0.5);
          }
          if (by <= 0 || by >= canvas.height - ballSize) vy *= -1;

          bx += vx;
          by += vy;

          const aiCenter = ax + paddleHeight / 2;
          if (aiCenter < by - 10) ax += 2;
          else if (aiCenter > by + 10) ax -= 2;
          ax = Math.max(0, Math.min(canvas.height - paddleHeight, ax));
        }

        drawScene(predCtx, 0, px, canvas.width - paddleWidth, ax, bx, by, vx, vy);
      }

      function loop() {
        updateGame();
        predictFuture();
        requestAnimationFrame(loop);
      }

      function resetBall() {
        ballX = canvas.width / 2;
        ballY = canvas.height / 2;
        ballVX = (Math.random() < 0.5 ? 3 : -3);
        ballVY = (Math.random() - 0.5) * 4;
      }

      loop();
    }
  </script>
</body>
</html>
