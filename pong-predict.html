<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Pong Predict</title>
  <style>
    * { box-sizing: border-box; }
    html, body {
      margin: 0;
      padding: 0;
      background: black;
      color: white;
      font-family: 'Courier New', monospace;
      font-size: 14px;
      overflow: hidden;
    }
    #container {
      display: flex;
      height: 100vh;
      width: 100vw;
    }
    canvas {
      display: block;
      background: black;
    }
    #intro {
      position: absolute;
      top: 0;
      left: 0;
      height: 100vh;
      width: 100vw;
      background: black;
      color: white;
      padding: 20px;
      font-size: 14px;
      z-index: 2;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
    }
    #intro pre {
      max-width: 600px;
      text-align: left;
    }
    #predict {
      filter: contrast(1.2) brightness(1.05) saturate(0.9);
      animation: flicker 5s infinite;
      position: relative;
    }
    @keyframes flicker {
      0%, 95%, 100% {
        opacity: 1;
      }
      96%, 97% {
        opacity: 0;
      }
    }
    .bounding-box {
      position: absolute;
      border: 1px solid white;
      pointer-events: none;
      z-index: 1;
    }
  </style>
</head>
<body>
  <div id="intro">
    <pre>
Open Testing: Pong Predict is a small scale experiment which will simulate ~120 games of pong in order to predict the outcome 5 seconds into the future. The display on the right will show the predicted score.

Press Esc to end the simulation.
Press Return to enter the simulation.

Note: I thought this was self explanatory but I got an email form David, who couldn't work out the up and down arrow keys move your paddle. Shame on you David. Also, sorry to our mobile workers, the simulation is in a primitive state and is almost unplayable on mobile.
    </pre>
  </div>
  <div id="container">
    <canvas id="main" width="400" height="300"></canvas>
    <canvas id="predict" width="400" height="300"></canvas>
  </div>
  <script>
    const intro = document.getElementById("intro");
    const mainCanvas = document.getElementById("main");
    const predictCanvas = document.getElementById("predict");
    const ctx = mainCanvas.getContext("2d");
    const pctx = predictCanvas.getContext("2d");

    let gameRunning = false;
    const WIDTH = 400, HEIGHT = 300;
    const paddleHeight = 40, paddleWidth = 5;
    const ballSize = 8;
    let playerY = HEIGHT / 2 - paddleHeight / 2;
    let aiY = HEIGHT / 2 - paddleHeight / 2;
    let ball = { x: WIDTH / 2, y: HEIGHT / 2, vx: -2, vy: 2 };
    let score = { player: 0, ai: 0 };

    function resetBall() {
      ball.x = WIDTH / 2;
      ball.y = HEIGHT / 2;
      const angle = (Math.random() * Math.PI / 2 - Math.PI / 4);
      const speed = 2 + Math.random();
      const direction = Math.random() < 0.5 ? -1 : 1;
      ball.vx = Math.cos(angle) * speed * direction;
      ball.vy = Math.sin(angle) * speed;
    }

    function drawGame(ctxDraw, ballState, playerYDraw, aiYDraw) {
      ctxDraw.clearRect(0, 0, WIDTH, HEIGHT);
      ctxDraw.fillStyle = "white";
      ctxDraw.fillRect(0, playerYDraw, paddleWidth, paddleHeight);
      ctxDraw.fillRect(WIDTH - paddleWidth, aiYDraw, paddleWidth, paddleHeight);
      ctxDraw.fillRect(ballState.x, ballState.y, ballSize, ballSize);
      ctxDraw.fillText(`You: ${score.player} | AI: ${score.ai}`, 10, 10);
    }

    function update() {
      if (!gameRunning) return;

      ball.x += ball.vx;
      ball.y += ball.vy;

      // Ball bounce on top/bottom
      if (ball.y <= 0 || ball.y + ballSize >= HEIGHT) {
        ball.vy *= -1;
      }

      // Paddle collisions
      if (ball.x <= paddleWidth && ball.y + ballSize >= playerY && ball.y <= playerY + paddleHeight) {
        ball.vx = Math.abs(ball.vx);
        ball.vy += (Math.random() - 0.5) * 2;
      }
      if (ball.x + ballSize >= WIDTH - paddleWidth && ball.y + ballSize >= aiY && ball.y <= aiY + paddleHeight) {
        ball.vx = -Math.abs(ball.vx);
        ball.vy += (Math.random() - 0.5) * 2;
      }

      // Score update
      if (ball.x < 0) {
        score.ai++;
        resetBall();
      }
      if (ball.x > WIDTH) {
        score.player++;
        resetBall();
      }

      // AI Movement
      if (aiY + paddleHeight / 2 < ball.y - 10) aiY += 1.5;
      else if (aiY + paddleHeight / 2 > ball.y + 10) aiY -= 1.5;

      drawGame(ctx, ball, playerY, aiY);
      simulatePrediction();
    }

    function simulatePrediction() {
      const simBall = { ...ball };
      let simPlayerY = playerY;
      let simAiY = aiY;

      for (let i = 0; i < 300; i++) {
        simBall.x += simBall.vx;
        simBall.y += simBall.vy;

        if (simBall.y <= 0 || simBall.y + ballSize >= HEIGHT) {
          simBall.vy *= -1;
        }

        if (simBall.x <= paddleWidth && simBall.y + ballSize >= simPlayerY && simBall.y <= simPlayerY + paddleHeight) {
          simBall.vx = Math.abs(simBall.vx);
          simBall.vy += (Math.random() - 0.5) * 2;
        }
        if (simBall.x + ballSize >= WIDTH - paddleWidth && simBall.y + ballSize >= simAiY && simBall.y <= simAiY + paddleHeight) {
          simBall.vx = -Math.abs(simBall.vx);
          simBall.vy += (Math.random() - 0.5) * 2;
        }

        if (simBall.x < 0 || simBall.x > WIDTH) break;

        if (simAiY + paddleHeight / 2 < simBall.y - 10) simAiY += 1.5;
        else if (simAiY + paddleHeight / 2 > simBall.y + 10) simAiY -= 1.5;
      }

      drawGame(pctx, simBall, simPlayerY, simAiY);
    }

    document.addEventListener("keydown", e => {
      if (!gameRunning) {
        if (e.key === "Enter") {
          intro.style.display = "none";
          gameRunning = true;
          return;
        }
      }

      if (e.key === "Escape") {
        gameRunning = false;
        intro.style.display = "flex";
      }

      if (e.key === "ArrowUp") playerY -= 10;
      if (e.key === "ArrowDown") playerY += 10;
    });

    setInterval(update, 1000 / 60);
  </script>
</body>
</html>
