<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Pong Predict</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      background: black;
      color: white;
      font-family: 'Courier New', monospace;
      overflow: hidden;
      height: 100%;
    }
    #intro {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: black;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      font-size: 14px;
      padding: 20px;
      box-sizing: border-box;
      text-align: center;
      z-index: 2;
    }
    #game {
      display: flex;
      width: 100vw;
      height: 100vh;
    }
    canvas {
      flex: 1;
      height: 100%;
    }
    .score {
      position: absolute;
      top: 10px;
      font-size: 28px;
      font-weight: bold;
      color: white;
      z-index: 1;
    }
    #playerScore {
      left: 20px;
    }
    #aiScore {
      right: 20px;
    }
    .vhs {
      filter: contrast(1.1) brightness(1.2);
      animation: flicker 5s infinite;
    }
    @keyframes flicker {
      0%, 90%, 100% { opacity: 1; }
      95% { opacity: 0; }
    }
  </style>
</head>
<body>
  <div id="intro">
    <p><strong>Open Testing:</strong> Pong Predict is a small-scale experiment which will simulate ~120 games of pong in order to predict the outcome 5 seconds into the future.</p>
    <p>The display on the right will show the predicted score.</p>
    <p>Press <strong>Esc</strong> to end the simulation.<br>Press <strong>Return</strong> to enter the simulation.</p>
    <p><em>Note:</em> I thought this was self-explanatory but I got an email from David, who couldn't work out the up and down arrow keys move your paddle. Shame on you, David.<br>Also, sorry to our mobile workers â€” the simulation is in a primitive state and is almost unplayable on mobile.</p>
  </div>
  <div id="playerScore" class="score">0</div>
  <div id="aiScore" class="score">0</div>
  <div id="game" style="display: none">
    <canvas id="gameCanvas"></canvas>
    <canvas id="predictionCanvas" class="vhs"></canvas>
  </div>

  <script>
    const intro = document.getElementById("intro");
    const gameContainer = document.getElementById("game");
    const playerScoreElem = document.getElementById("playerScore");
    const aiScoreElem = document.getElementById("aiScore");

    let started = false;
    document.addEventListener("keydown", (e) => {
      if (e.key === "Enter" && !started) {
        intro.style.display = "none";
        gameContainer.style.display = "flex";
        started = true;
        startGame();
      }
    });

    function startGame() {
      const canvas = document.getElementById("gameCanvas");
      const ctx = canvas.getContext("2d");
      const predCanvas = document.getElementById("predictionCanvas");
      const predCtx = predCanvas.getContext("2d");

      canvas.width = predCanvas.width = window.innerWidth / 2;
      canvas.height = predCanvas.height = window.innerHeight;

      const paddleHeight = 100, paddleWidth = 10, ballSize = 10;
      let playerY = canvas.height / 2 - paddleHeight / 2;
      let aiY = playerY;
      let ballX = canvas.width / 2, ballY = canvas.height / 2;
      let ballVX = 3, ballVY = 2;
      let playerScore = 0, aiScore = 0;

      const keys = {};
      document.addEventListener("keydown", (e) => keys[e.key] = true);
      document.addEventListener("keyup", (e) => keys[e.key] = false);

      function draw(ctx, px, py, ax, ay, bx, by) {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = "white";
        ctx.fillRect(0, py, paddleWidth, paddleHeight);
        ctx.fillRect(canvas.width - paddleWidth, ay, paddleWidth, paddleHeight);
        ctx.fillRect(bx, by, ballSize, ballSize);

        // Bounding box prediction
        ctx.strokeStyle = "white";
        for (let i = 1; i <= 3; i++) {
          ctx.strokeRect(bx + ballVX * i * 20, by + ballVY * i * 20, ballSize, ballSize);
        }
      }

      function update() {
        // Player control
        if (keys["ArrowUp"]) playerY -= 4;
        if (keys["ArrowDown"]) playerY += 4;
        playerY = Math.max(0, Math.min(canvas.height - paddleHeight, playerY));

        // AI follows with delay
        const centerAI = aiY + paddleHeight / 2;
        if (centerAI < ballY - 10) aiY += 2;
        else if (centerAI > ballY + 10) aiY -= 2;
        aiY = Math.max(0, Math.min(canvas.height - paddleHeight, aiY));

        // Move ball
        ballX += ballVX;
        ballY += ballVY;

        if (ballY < 0 || ballY > canvas.height - ballSize) ballVY = -ballVY;

        // Paddle collisions
        if (ballX < paddleWidth && ballY + ballSize > playerY && ballY < playerY + paddleHeight) {
          ballVX = Math.abs(ballVX);
          ballVY += (Math.random() - 0.5) * 2;
        }
        if (ballX > canvas.width - paddleWidth - ballSize && ballY + ballSize > aiY && ballY < aiY + paddleHeight) {
          ballVX = -Math.abs(ballVX);
          ballVY += (Math.random() - 0.5) * 2;
        }

        if (ballX < 0) {
          aiScore++;
          resetBall();
        }
        if (ballX > canvas.width) {
          playerScore++;
          resetBall();
        }

        playerScoreElem.textContent = playerScore;
        aiScoreElem.textContent = aiScore;

        draw(ctx, 0, playerY, canvas.width - paddleWidth, aiY, ballX, ballY);
      }

      function resetBall() {
        ballX = canvas.width / 2;
        ballY = canvas.height / 2;
        ballVX = (Math.random() < 0.5 ? 3 : -3);
        ballVY = (Math.random() - 0.5) * 4;
      }

      function predict() {
        let px = playerY;
        let ax = aiY;
        let bx = ballX;
        let by = ballY;
        let vx = ballVX;
        let vy = ballVY;

        for (let i = 0; i < 300; i++) {
          if (bx < paddleWidth && by + ballSize > px && by < px + paddleHeight) {
            vx = Math.abs(vx);
            vy += (Math.random() - 0.5);
          }
          if (bx > canvas.width - paddleWidth - ballSize && by + ballSize > ax && by < ax + paddleHeight) {
            vx = -Math.abs(vx);
            vy += (Math.random() - 0.5);
          }
          if (by < 0 || by > canvas.height - ballSize) vy = -vy;

          bx += vx;
          by += vy;

          const centerAI = ax + paddleHeight / 2;
          if (centerAI < by - 10) ax += 2;
          else if (centerAI > by + 10) ax -= 2;
          ax = Math.max(0, Math.min(canvas.height - paddleHeight, ax));
        }

        draw(predCtx, 0, px, canvas.width - paddleWidth, ax, bx, by);
      }

      function loop() {
        update();
        predict();
        requestAnimationFrame(loop);
      }
      loop();
    }
  </script>
</body>
</html>
