<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Pong Predict</title>
  <style>
    * {
      box-sizing: border-box;
    }
    body {
      margin: 0;
      background: black;
      color: white;
      font-family: 'Courier New', monospace;
      overflow: hidden;
    }
    #container {
      display: flex;
      width: 100vw;
      height: 100vh;
    }
    canvas {
      flex: 1;
      background: black;
    }
    #intro {
      position: absolute;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: black;
      color: white;
      font-size: 14px;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 40px;
      text-align: left;
      line-height: 1.6;
      z-index: 10;
    }
    .vhs {
      position: absolute;
      width: 100%;
      height: 100%;
      background: repeating-linear-gradient(
        0deg,
        rgba(255, 255, 255, 0.02),
        rgba(255, 255, 255, 0.02) 2px,
        transparent 2px,
        transparent 4px
      );
      mix-blend-mode: overlay;
      pointer-events: none;
      animation: flicker 3s infinite;
    }
    @keyframes flicker {
      0%, 90%, 100% { opacity: 1; }
      91%, 95% { opacity: 0; }
    }
  </style>
</head>
<body>
  <div id="intro">
    <div>
      <p><strong>Open Testing:</strong> Pong Predict is a small scale experiment which will simulate ~120 games of pong in order to predict the outcome 5 seconds into the future. The display on the right will show the predicted score.</p>
      <p><strong>Press ESC</strong> to end the simulation.<br><strong>Press RETURN</strong> to enter the simulation.</p>
      <p><em>Note:</em> I thought this was self explanatory but I got an email from David, who couldn't work out the up and down arrow keys move your paddle. Shame on you David. Also, sorry to our mobile workers, the simulation is in a primitive state and is almost unplayable on mobile.</p>
    </div>
  </div>
  <div id="container">
    <canvas id="live"></canvas>
    <canvas id="predicted"></canvas>
    <div class="vhs"></div>
  </div>
  <script>
    const intro = document.getElementById("intro");
    let started = false;

    const canvasLive = document.getElementById("live");
    const canvasPred = document.getElementById("predicted");
    const ctxLive = canvasLive.getContext("2d");
    const ctxPred = canvasPred.getContext("2d");

    canvasLive.width = canvasPred.width = window.innerWidth / 2;
    canvasLive.height = canvasPred.height = window.innerHeight;

    const paddleHeight = 80;
    const paddleWidth = 10;
    let playerY = canvasLive.height / 2 - paddleHeight / 2;
    let aiY = canvasLive.height / 2 - paddleHeight / 2;
    const paddleSpeed = 4;

    const ballSize = 10;
    let ball = {
      x: canvasLive.width / 2,
      y: canvasLive.height / 2,
      vx: 3,
      vy: 2,
    };

    let score = { player: 0, ai: 0 };

    const keys = {};
    window.addEventListener("keydown", (e) => {
      keys[e.key] = true;
      if (e.key === "Escape") location.reload();
      if (e.key === "Enter" && !started) {
        started = true;
        intro.style.display = "none";
        loop();
      }
    });
    window.addEventListener("keyup", (e) => {
      keys[e.key] = false;
    });

    function draw(ctx, ball, playerY, aiY, score) {
      ctx.clearRect(0, 0, canvasLive.width, canvasLive.height);

      // bounding box
      ctx.strokeStyle = "white";
      ctx.strokeRect(0, 0, canvasLive.width, canvasLive.height);

      // paddles
      ctx.fillStyle = "white";
      ctx.fillRect(10, playerY, paddleWidth, paddleHeight);
      ctx.fillRect(canvasLive.width - 20, aiY, paddleWidth, paddleHeight);

      // ball
      ctx.fillRect(ball.x, ball.y, ballSize, ballSize);

      // score
      ctx.font = "16px Courier New";
      ctx.fillText(`You: ${score.player}`, 20, 20);
      ctx.fillText(`AI: ${score.ai}`, canvasLive.width - 100, 20);
    }

    function moveAI(ball, aiY) {
      const target = ball.y - paddleHeight / 2 + ballSize / 2;
      return aiY + (target > aiY ? 2 : -2);
    }

    function update(ball, playerY, aiY, score) {
      ball.x += ball.vx;
      ball.y += ball.vy;

      // wall bounce
      if (ball.y <= 0 || ball.y + ballSize >= canvasLive.height) {
        ball.vy *= -1;
      }

      // paddle bounce + randomness
      if (
        ball.x <= 20 &&
        ball.y + ballSize >= playerY &&
        ball.y <= playerY + paddleHeight
      ) {
        ball.vx = Math.abs(ball.vx);
        ball.vy += (Math.random() - 0.5) * 2;
      }
      if (
        ball.x + ballSize >= canvasLive.width - 20 &&
        ball.y + ballSize >= aiY &&
        ball.y <= aiY + paddleHeight
      ) {
        ball.vx = -Math.abs(ball.vx);
        ball.vy += (Math.random() - 0.5) * 2;
      }

      // scoring
      if (ball.x < 0) {
        score.ai++;
        reset(ball);
      } else if (ball.x > canvasLive.width) {
        score.player++;
        reset(ball);
      }

      return { ball, playerY, aiY, score };
    }

    function reset(ball) {
      ball.x = canvasLive.width / 2;
      ball.y = canvasLive.height / 2;
      ball.vx = 3 * (Math.random() > 0.5 ? 1 : -1);
      ball.vy = 2 * (Math.random() > 0.5 ? 1 : -1);
    }

    function predictState(initialBall, aiY, frames = 300) {
      let b = { ...initialBall };
      let aY = aiY;
      let s = { ...score };
      for (let i = 0; i < frames; i++) {
        aY = moveAI(b, aY);
        ({ ball: b, aiY: aY, score: s } = update(b, playerY, aY, s));
      }
      return { ball: b, aiY: aY, score: s };
    }

    function loop() {
      if (keys.ArrowUp) playerY -= paddleSpeed;
      if (keys.ArrowDown) playerY += paddleSpeed;
      aiY = moveAI(ball, aiY);

      update(ball, playerY, aiY, score);
      draw(ctxLive, ball, playerY, aiY, score);

      // predict
      const pred = predictState(ball, aiY);
      draw(ctxPred, pred.ball, playerY, pred.aiY, pred.score);

      requestAnimationFrame(loop);
    }
  </script>
</body>
</html>
