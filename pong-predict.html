<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Pong Predict</title>
  <style>
    body {
      margin: 0;
      padding: 0;
      background-color: black;
      color: white;
      font-family: 'Courier New', monospace;
      font-size: 14px;
      overflow: hidden;
    }

    #intro {
      position: absolute;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background-color: black;
      color: white;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      text-align: center;
      padding: 30px;
      z-index: 10;
    }

    #intro p {
      margin-bottom: 15px;
      line-height: 1.5;
    }

    #container {
      display: flex;
      width: 100vw;
      height: 100vh;
    }

    canvas {
      flex: 1;
      height: 100vh;
    }

    #prediction {
      filter: contrast(1.1) brightness(0.95);
      animation: flicker 0.3s infinite alternate;
    }

    @keyframes flicker {
      0%, 100% { opacity: 1; }
      90% { opacity: 0.95; }
      95% { opacity: 0; }
    }
  </style>
</head>
<body>
  <div id="intro">
    <p><strong>Open Testing: Pong Predict</strong> is a small-scale experiment which simulates ~120 games of Pong to predict the outcome 5 seconds into the future.</p>
    <p>The display on the right shows the predicted score and ball positions.</p>
    <p><em>Press Esc</em> to end the simulation.<br>
    <em>Press Return</em> to enter the simulation.</p>
    <p><small>Note: Apparently I have to say this, but the Up and Down arrow keys move your paddle. David didn't know. Shame on you, David. Sorry mobile folksâ€”this version is kinda garbage on phones ðŸ’€</small></p>
  </div>

  <div id="container" style="display: none;">
    <canvas id="game"></canvas>
    <canvas id="prediction"></canvas>
  </div>

  <script>
    const intro = document.getElementById("intro");
    const container = document.getElementById("container");
    const canvas = document.getElementById("game");
    const pCanvas = document.getElementById("prediction");
    const ctx = canvas.getContext("2d");
    const pCtx = pCanvas.getContext("2d");

    canvas.width = pCanvas.width = window.innerWidth / 2;
    canvas.height = pCanvas.height = window.innerHeight;

    const paddleHeight = 80;
    const paddleWidth = 10;
    const ballSize = 10;
    let playerY = canvas.height / 2 - paddleHeight / 2;
    let aiY = canvas.height / 2 - paddleHeight / 2;
    let ball = { x: canvas.width / 2, y: canvas.height / 2, vx: 3, vy: 2 };
    let score = { player: 0, ai: 0 };

    let keys = {};

    function drawGame(ctx, ball, playerY, aiY, showBounds = false) {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.fillStyle = "white";

      if (showBounds) {
        ctx.strokeStyle = 'white';
        ctx.strokeRect(0, 0, canvas.width, canvas.height);
      }

      ctx.fillRect(10, playerY, paddleWidth, paddleHeight);
      ctx.fillRect(canvas.width - 20, aiY, paddleWidth, paddleHeight);
      ctx.fillRect(ball.x, ball.y, ballSize, ballSize);
      ctx.fillText(`Player: ${score.player}  AI: ${score.ai}`, canvas.width / 2 - 40, 20);
    }

    function clamp(val, min, max) {
      return Math.max(min, Math.min(max, val));
    }

    function updateGame(state, keys) {
      if (keys["ArrowUp"]) state.playerY -= 4;
      if (keys["ArrowDown"]) state.playerY += 4;

      state.playerY = clamp(state.playerY, 0, canvas.height - paddleHeight);

      const center = state.ball.y + ballSize / 2;
      const aiCenter = state.aiY + paddleHeight / 2;
      state.aiY += (center < aiCenter ? -2 : 2);
      state.aiY = clamp(state.aiY, 0, canvas.height - paddleHeight);

      state.ball.x += state.ball.vx;
      state.ball.y += state.ball.vy;

      if (state.ball.y <= 0 || state.ball.y + ballSize >= canvas.height) {
        state.ball.vy *= -1;
      }

      if (state.ball.x <= 20 && state.ball.y + ballSize >= state.playerY && state.ball.y <= state.playerY + paddleHeight) {
        state.ball.vx = Math.abs(state.ball.vx);
        state.ball.vy = (Math.random() * 4 - 2);
      }

      if (state.ball.x + ballSize >= canvas.width - 20 && state.ball.y + ballSize >= state.aiY && state.ball.y <= state.aiY + paddleHeight) {
        state.ball.vx = -Math.abs(state.ball.vx);
        state.ball.vy = (Math.random() * 4 - 2);
      }

      if (state.ball.x < 0) {
        state.score.ai++;
        resetBall(state);
      } else if (state.ball.x > canvas.width) {
        state.score.player++;
        resetBall(state);
      }
    }

    function resetBall(state) {
      state.ball = { x: canvas.width / 2, y: canvas.height / 2, vx: (Math.random() > 0.5 ? 3 : -3), vy: Math.random() * 4 - 2 };
    }

    function predictFuture(state, frames) {
      const clone = JSON.parse(JSON.stringify(state));
      for (let i = 0; i < frames; i++) {
        updateGame(clone, {});
      }
      return clone;
    }

    function loop() {
      updateGame(gameState, keys);
      drawGame(ctx, gameState.ball, gameState.playerY, gameState.aiY);

      const prediction = predictFuture(gameState, 300);
      drawGame(pCtx, prediction.ball, prediction.playerY, prediction.aiY, true);

      requestAnimationFrame(loop);
    }

    let gameState = {
      playerY,
      aiY,
      ball,
      score: { ...score }
    };

    window.addEventListener("keydown", e => {
      keys[e.key] = true;
      if (e.key === "Escape") window.location.reload();
      if (e.key === "Enter") {
        intro.style.display = "none";
        container.style.display = "flex";
        loop();
      }
    });

    window.addEventListener("keyup", e => keys[e.key] = false);
  </script>
</body>
</html>
